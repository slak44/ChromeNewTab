'use strict';

/**
  This object handles all persistent data storage. Most data is stored in chrome.storage.local, because it can get
  quite large, but the *Cached functions use localStorage for performance reasons (and because we can afford to block
  on cache fetches).
  @see window.stored
*/
window.storage = window.storage || {};
/**
  The object where window.storage places it's items.
  @see window.storage
*/
window.stored = window.stored || {};

/**
  Map of tracked objects.
  Each key is a property name on the window.stored object.
  Each value is an object that has an `init` property, and a `default` property.
  The initialization value is a fallback in case the objects don't get loaded.
  The default value is used for new users/people who restored to defaults, aka when the storage is empty.
  @see window.storage
*/
storage.elements = Object.freeze({
  plugins: {init: [], 'default': []},
  buttons: {init: [], 'default': require('json-loader!default-buttons')},
  themes: {init: [require('json-loader!default-theme')], 'default': [require('json-loader!default-theme')]},
  currentThemeIdx: {init: 0, 'default': 0},
  hasSeenSaveButton: {init: true, 'default': false}
});
/**
  Checks whether or not an element is tracked.
  @param element a string that's a key in storage.elements
  @returns true if it is tracked, false otherwise
  @see storage.elements
*/
storage.isStored = element => Object.keys(storage.elements).includes(element);
/**
  Set all elements to their init value, then load all elements from storage.
  @returns a Promise that resolves when the elements have been loaded
*/
storage.loadAll = () => new Promise((resolve, reject) => {
  const defaults = {};
  // Set items to initialization values and gather defaults
  Object.keys(storage.elements).forEach(key => {
    stored[key] = storage.elements[key].init;
    defaults[key] = storage.elements[key].default;
  });
  chrome.storage.local.get(defaults, items => {
    stored = items;
    resolve(items);
  });
});
/**
  Persist all tracked global objects into storage.
  @returns a Promise that resolves when the data was stored
*/
storage.storeAll = () => new Promise((resolve, reject) => chrome.storage.local.set(stored, resolve));
/**
  Persist a particular global object into storage.
  @param element a string that's a key in storage.elements
  @returns a Promise that resolves when the element was stored, and rejects if the given element is not tracked
*/
storage.store = element => new Promise((resolve, reject) => {
  if (!storage.isStored(element)) reject(new Error(`Element not tracked: ${element}`));
  const objToStore = {};
  objToStore[element] = stored[element];
  chrome.storage.local.set(objToStore, resolve);
});
/**
  Deletes storage for an element, and removes the associated global object.
  @param element a string that's a key in storage.elements
  @returns a Promise that resolves when the data was deleted, and rejects if the given element is not tracked
*/
storage.clear = element => new Promise((resolve, reject) => {
  if (!storage.isStored(element)) reject(new Error(`Element not tracked: ${element}`));
  delete stored[element];
  const objToStore = {};
  objToStore[element] = {};
  chrome.storage.local.set(objToStore, resolve);
});
/** Delete all global objects and clear persistent storage. */
storage.clearAll = () => {
  stored = {};
  chrome.storage.local.clear();
};

/** Map of cacheable things */
storage.cacheable = Object.freeze({
  precompiledStyles: 'precompiledStylesKey',
  buttons: 'cachedButtonsKey'
});
/**
  Checks whether or not a string is a valid cache key.
  @param key a value from storage.cacheable
  @returns true if valid, false otherwise
*/
storage.isCached = key => Object.values(storage.cacheable).includes(key);
/**
  Load cached data from localStorage.
  @param key a value from storage.cacheable
  @returns a Promise that resolves with the data if it existed, null if it didn't, and rejects if the key is not valid
*/
storage.loadCached = key => new Promise((resolve, reject) => {
  if (!storage.isCached(key)) reject(new Error(`Cache key does not exist: ${key}`));
  resolve(localStorage.getItem(key));
});
/**
  Store something in localStorage.
  @param key a value from storage.cacheable
  @param item the value to store
*/
storage.storeCached = (key, item) => {
  if (!storage.isCached(key)) throw Error(`Cache key does not exist: ${key}`);
  localStorage.setItem(key, item);
};
/**
  Delete cached value by key.
  @param key a value from storage.cacheable
*/
storage.clearCached = key => {
  if (!storage.isCached(key)) throw Error(`Cache key does not exist: ${key}`);
  localStorage.clear(key);
};
/** Clear all cached data */
storage.clearAllCached = () => Object.values(storage.cacheable).forEach(cacheKey => storage.clearCached(cacheKey));
