'use strict';

window.dependencies = {};

window.$ = window.jQuery = require('jquery');
window.Materialize = require('materialize-css');
const async = require('async');
const themeUtils = require('themes');

window.plugins = [];
window.buttons = [];
window.themes = [];
window.currentThemeIdx = 0;

window.capitalize = string => string.charAt(0).toUpperCase() + string.substr(1);

window.SHORT_DURATION_MS = 3000; // 3 seconds
window.LONG_DURATION_MS = 10000; // 10 seconds

/*
  Handles localStorage access.
*/
window.storage = new (function () {
  const self = this;

  /*
    Constant.
    Existing storage elements. Usable as 'element' parameters for the other functions in this object.
  */
  this.stored = ['plugins', 'buttons', 'themes', 'currentThemeIdx'];
  Object.freeze(this.stored);

  /*
    Checks whether or not an element is being stored in this object.
  */
  this.isStored = element => this.stored.includes(element);

  /*
    Private utility function that throws an error if the element is not in the `stored` array.
  */
  function throwIfNotStored(element) {
    if (!self.isStored(element)) throw new Error(`The element ${element} does not exist in this object`);
  }

  /*
    Private utility function that returns where in local storage was the element placed.
  */
  function storedNameFrom(element) {
    return `stored${capitalize(element)}`;
  }

  /*
    Load a stored element in a global object with the same name.
  */
  this.load = function (element, callback) {
    throwIfNotStored(element);
    chrome.storage.local.get(storedNameFrom(element), data => {
      if (data && data[storedNameFrom(element)]) {
        window[element] = data[storedNameFrom(element)];
        callback(null);
      } else {
        self.store(element, callback);
      }
    });
  };

  /*
    Stores an element in the browser storage.
    The name used for storage is 'stored' + the name of the element, capitalized.
    To store a new element, it must be first added to the `stored` array.
  */
  this.store = function (element, callback) {
    throwIfNotStored(element);
    const objToStore = {};
    objToStore[storedNameFrom(element)] = window[element];
    chrome.storage.local.set(objToStore, callback);
  };

  /*
    Deletes all elements, both from their respective global objects and from the storage.
  */
  this.clearStorage = function () {
    this.stored.forEach(element => delete window[element]);
    chrome.storage.local.clear();
  };

  /*
    Only deletes a single element.
  */
  this.clear = function (element, callback) {
    throwIfNotStored(element);
    delete window[element];
    const objToStore = {};
    objToStore[storedNameFrom(element)] = {};
    chrome.storage.local.set(objToStore, callback);
  };
})();

/*
  Provides utilities for plugins. Each plugin should create its own instance.
*/
window.PluginUtil = function (plugin) {
  /*
    Get the value of a setting by its name.
  */
  this.getSetting = function (settingName) {
    return plugin.settings.filter(settingObj => settingObj.name === settingName)[0].value;
  };

  /*
    Dynamically adds a plugin's css.
  */
  this.insertStyles = function (cssText) {
    $('#plugin-css').append(cssText);
  };

  /*
    Shortcut to plugin dependencies.
  */
  this.deps = window.dependencies[plugin.name];
};

window.onInstallSetup = function () {
  themes = [themeUtils.defaultTheme];
  buttons = [
    {kind: 'subheader', text: 'Check out the settings!', position: 0},
    {text: 'Settings', pictureType: 'icon', ligatureName: 'settings', kind: 'default',
      href: '/secondary/secondary.html', position: 1, hotkey: '', imagePath: ''}
  ];
  storage.store('buttons');
  storage.store('themes');
};

chrome.runtime.onInstalled.addListener(details => {
  if (details.reason === 'install') onInstallSetup();
});

async.parallel([cb => storage.load('themes', cb), cb => storage.load('currentThemeIdx', cb)], err => {
  if (err) {
    console.error(err);
    Materialize.toast($('<span>Error loading themes</span>'), SHORT_DURATION_MS);
  }
  themeUtils.activateTheme(themes[currentThemeIdx] || themeUtils.defaultTheme);
});

window.runViewContent = function (plugin, view) {
  try {
    if (plugin.dependencyCode && view === 'global') eval(plugin.dependencyCode);
    if (plugin.html[view]) Object.keys(plugin.html[view]).forEach((selector, i, array) => {
      document.querySelector(selector).insertAdjacentHTML('beforeend', array[selector]);
    });
    if (plugin.css[view]) $('#plugin-css').innerHTML += plugin.css[view];
    if (plugin.js[view]) eval(plugin.js[view]);
  } catch (err) {
    Materialize.toast($(`<span>Plugin ${plugin.name} encountered an error</span>`), SHORT_DURATION_MS);
    console.error(`Execution for ${plugin.name} failed in ${view}: `, err);
  }
};

window.undoToast = function (text, uid, performUndo) {
  const content = $(`<span>${text}</span>`)
    .add($(`<button id="undo-${uid}" class="btn-flat toast-action">Undo</button>`));
  Materialize.toast(content, LONG_DURATION_MS);
  const undoBtn = $(`#undo-${uid}`);
  undoBtn.click(event => {
    performUndo();
    undoBtn.parent()[0].M_Toast.remove();
  });
};
